// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2
// RUN: %clang_cc1 -triple v810 -emit-llvm %s -o - -O2 | FileCheck %s

#include <stdint.h>

// CHECK-LABEL: define dso_local void @f_void
// CHECK-SAME: () local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void f_void(void) {}

struct ConvenientSize {
    uint8_t field1;
    uint16_t field2;
    uint32_t field3;
    int32_t field4;
};

struct InconvenientSize {
    struct ConvenientSize one;
    uint8_t two;
};

// four-field structs can be passed in by register

// CHECK-LABEL: define dso_local void @f_allregs
// CHECK-SAME: (i8 [[FITSPARAM_COERCE0:%.*]], i16 [[FITSPARAM_COERCE1:%.*]], i32 [[FITSPARAM_COERCE2:%.*]], i32 [[FITSPARAM_COERCE3:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void f_allregs(struct ConvenientSize fitsparam) {}

// more than that? doesn't fit

// CHECK-LABEL: define dso_local void @f_too_big
// CHECK-SAME: (ptr nocapture noundef readnone byval([[STRUCT_INCONVENIENTSIZE:%.*]]) align 4 [[UNFITSPARAM:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void f_too_big(struct InconvenientSize unfitsparam) {}

// 64-bit values are passed in two registers each

// CHECK-LABEL: define dso_local noundef i64 @f_u64
// CHECK-SAME: (i64 noundef returned [[PARAM:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i64 [[PARAM]]
//
uint64_t f_u64(uint64_t param) {
    return param;
}

// returning one two-field struct can be done in registers

struct TwoRegisters {
    int32_t reg1;
    int32_t reg2;
};

// CHECK-LABEL: define dso_local %struct.TwoRegisters @f_returninregs
// CHECK-SAME: () local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret [[STRUCT_TWOREGISTERS:%.*]] zeroinitializer
//
struct TwoRegisters f_returninregs() {
    struct TwoRegisters val = {
        .reg1 = 0,
        .reg2 = 0,
    };
    return val;
}

// returning one three-field-struct? use an sret

struct ThreeRegisters {
    int32_t reg1;
    int32_t reg2;
    int32_t reg3;
};

// CHECK-LABEL: define dso_local void @f_returninsret
// CHECK-SAME: (ptr dead_on_unwind noalias nocapture writable writeonly sret([[STRUCT_THREEREGISTERS:%.*]]) align 4 initializes((0, 12)) [[AGG_RESULT:%.*]]) local_unnamed_addr #[[ATTR2:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(12) [[AGG_RESULT]], i8 0, i32 12, i1 false)
// CHECK-NEXT:    ret void
//
struct ThreeRegisters f_returninsret() {
    struct ThreeRegisters val = {
        .reg1 = 0,
        .reg2 = 0,
        .reg3 = 0,
    };
    return val;
}
