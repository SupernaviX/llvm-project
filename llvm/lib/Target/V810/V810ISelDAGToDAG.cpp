#include "V810TargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
using namespace llvm;

#define DEBUG_TYPE "v810-isel"
#define PASS_NAME "V810 DAG-> DAG Pattern Instruction Selection"

namespace {
class V810DAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the Sparc Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const V810Subtarget *Subtarget = nullptr;
public:
  static char ID;

  V810DAGToDAGISel() = delete;

  explicit V810DAGToDAGISel(V810TargetMachine &tm) : SelectionDAGISel(ID, tm) {}

  StringRef getPassName() const override { return PASS_NAME; }

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<V810Subtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void Select(SDNode *N) override;

  void SelectMUL_LOHI(SDNode *N, bool isSigned);
  void SelectDIVREM(SDNode *N, bool isSigned);

  // Complex Pattern Selectors.
  bool SelectADDR(SDValue N, SDValue &Value);
  bool SelectADDRri(SDValue N, SDValue &Base, SDValue &Offset);

  // Include the pieces autogenerated from the target description.
#include "V810GenDAGISel.inc"
};
} // end anonymous namespace

char V810DAGToDAGISel::ID = 0;

INITIALIZE_PASS(V810DAGToDAGISel, DEBUG_TYPE, PASS_NAME, false, false)

bool V810DAGToDAGISel::SelectADDR(SDValue Addr, SDValue &Value) {
  if (GlobalAddressSDNode *GN = dyn_cast<GlobalAddressSDNode>(Addr)) {
    Value = CurDAG->getTargetGlobalAddress(GN->getGlobal(), SDLoc(Addr), MVT::Other);
    return true;
  }
  return false;
}

bool V810DAGToDAGISel::SelectADDRri(SDValue Addr,
                                    SDValue &Base, SDValue &Offset) {
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(
      FIN->getIndex(), TLI->getPointerTy(CurDAG->getDataLayout()));
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
    return true;
  }
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress)
    return false; // direct calls.
  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    ConstantSDNode *CN = cast<ConstantSDNode>(Addr.getOperand(1));
    if (isInt<16>(CN->getSExtValue())) {
      if (FrameIndexSDNode *FIN =
              dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
        // Constant offset from frame ref.
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), Addr->getValueType(0));
      } else {
        Base = Addr.getOperand(0);
      }
      Offset =
          CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr), MVT::i32);
      return true;
    }
  }
  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr)) {
    // When working with constant addresses, MOVHI the high bits and stick the low bits in the offset
    uint64_t lo = CN->getSExtValue() & 0xffff;
    uint64_t hi = ((CN->getSExtValue() >> 16) & 0xffff) + ((lo & 0x8000) != 0);
    SDValue Ops[] = {CurDAG->getRegister(V810::R0, MVT::i32), CurDAG->getTargetConstant(hi, SDLoc(Addr), MVT::i32)};
    Base = SDValue(CurDAG->getMachineNode(V810::MOVHI, SDLoc(Addr), MVT::i32, Ops), 0);
    Offset = CurDAG->getTargetConstant(lo, SDLoc(Addr), MVT::i32);
    return true;
  }
  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
  return true;
}

void V810DAGToDAGISel::SelectMUL_LOHI(SDNode *N, bool isSigned) {
  unsigned Opc = isSigned ? V810::MUL : V810::MULU;
  SDLoc DL(N);
  SDValue Ops[] = {N->getOperand(0), N->getOperand(1)};
  SDNode *Mad = CurDAG->getMachineNode(Opc, DL, N->getVTList(), Ops);

  SDValue Chain = CurDAG->getEntryNode();
  if (!SDValue(N, 0).use_empty()) {
    ReplaceUses(SDValue(N, 0), SDValue(Mad, 0));
  }
  if (!SDValue(N, 1).use_empty()) {
    SDValue ValueFromR30 = CurDAG->getCopyFromReg(Chain, DL, V810::R30,
                                                  SDValue(N, 1).getValueType());
    ReplaceUses(SDValue(N, 1), ValueFromR30);
  }
  CurDAG->RemoveDeadNode(N);
}

void V810DAGToDAGISel::SelectDIVREM(SDNode *N, bool isSigned) {
  unsigned Opc = isSigned ? V810::DIV : V810::DIVU;
  SDLoc DL(N);
  SDValue Ops[] = {N->getOperand(0), N->getOperand(1)};
  SDNode *Mad = CurDAG->getMachineNode(Opc, DL, N->getVTList(), Ops);

  SDValue Chain = CurDAG->getEntryNode();
  if (!SDValue(N, 0).use_empty()) {
    ReplaceUses(SDValue(N, 0), SDValue(Mad, 0));
  }
  if (!SDValue(N, 1).use_empty()) {
    SDValue ValueFromR30 = CurDAG->getCopyFromReg(Chain, DL, V810::R30,
                                                  SDValue(N, 1).getValueType());
    ReplaceUses(SDValue(N, 1), ValueFromR30);
  }
  CurDAG->RemoveDeadNode(N);
}

void V810DAGToDAGISel::Select(SDNode *N) {
  if (N->isMachineOpcode()) {
    N->setNodeId(-1);
    return; // Already selected.
  }

  switch (N->getOpcode()) {
  default:
    break;
  case ISD::SMUL_LOHI:
    SelectMUL_LOHI(N, true);
    return;
  case ISD::UMUL_LOHI:
    SelectMUL_LOHI(N, false);
    return;
  case ISD::SDIVREM:
    SelectDIVREM(N, true);
    return;
  case ISD::UDIVREM:
    SelectDIVREM(N, false);
    return;
  }

  SelectCode(N);
}

FunctionPass *llvm::createV810IselDag(V810TargetMachine &TM) {
  return new V810DAGToDAGISel(TM);
}