; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s -march=v810 -global-isel | FileCheck %s

declare i32 @func1()
declare i32 @func2()

define i32 @conditionCheck(i32 %input) {
; CHECK-LABEL: conditionCheck:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    add -4, r3
; CHECK-NEXT:    cmp 3, r6
; CHECK-NEXT:    st.w r31, 0[r3] # 4-byte Folded Spill
; CHECK-NEXT:    bge .LBB0_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    jal func1
; CHECK-NEXT:    br .LBB0_3
; CHECK-NEXT:  .LBB0_2: # %else
; CHECK-NEXT:    jal func2
; CHECK-NEXT:  .LBB0_3: # %then
; CHECK-NEXT:    ld.w 0[r3], r31 # 4-byte Folded Reload
; CHECK-NEXT:    add 4, r3
; CHECK-NEXT:    jmp [r31]
entry:
  %cond = icmp slt i32 %input, 3
  br i1 %cond, label %then, label %else
then:
  %res1 = call i32 @func1()
  ret i32 %res1
else:
  %res2 = call i32 @func2()
  ret i32 %res2
}

define i32 @boolCheck(i1 %cond) {
; CHECK-LABEL: boolCheck:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    add -4, r3
; CHECK-NEXT:    cmp 0, r6
; CHECK-NEXT:    st.w r31, 0[r3] # 4-byte Folded Spill
; CHECK-NEXT:    be .LBB1_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    jal func1
; CHECK-NEXT:    br .LBB1_3
; CHECK-NEXT:  .LBB1_2: # %else
; CHECK-NEXT:    jal func2
; CHECK-NEXT:  .LBB1_3: # %then
; CHECK-NEXT:    ld.w 0[r3], r31 # 4-byte Folded Reload
; CHECK-NEXT:    add 4, r3
; CHECK-NEXT:    jmp [r31]
entry:
  br i1 %cond, label %then, label %else
then:
  %res1 = call i32 @func1()
  ret i32 %res1
else:
  %res2 = call i32 @func2()
  ret i32 %res2
}
